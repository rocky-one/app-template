<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL图像滤镜实现</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-size: 3.5rem;
            margin-bottom: 15px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.4rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            flex: 1;
            min-width: 300px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #ffd700;
            position: relative;
            padding-bottom: 10px;
        }
        
        .control-group h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 3px;
            background: #3498db;
            border-radius: 2px;
        }
        
        .filter-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
        }
        
        .filter-btn {
            background: rgba(52, 152, 219, 0.7);
            border: none;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .filter-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }
        
        .filter-btn.active {
            background: #e74c3c;
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.5);
        }
        
        .slider-control {
            margin: 15px 0;
        }
        
        .slider-control label {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .slider-control input {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-control input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .canvas-container {
            flex: 2;
            min-width: 500px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .canvas-title {
            font-size: 1.8rem;
            color: #ffd700;
        }
        
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        canvas {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .info-panel h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #ffd700;
        }
        
        .info-content {
            line-height: 1.8;
            font-size: 1.1rem;
        }
        
        .tech-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .tech-item {
            background: rgba(52, 152, 219, 0.2);
            padding: 15px;
            border-radius: 10px;
        }
        
        .tech-item h3 {
            color: #ffd700;
            margin-bottom: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            width: 100%;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .canvas-container {
                min-width: 100%;
            }
            
            h1 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>WebGL图像滤镜实现</h1>
            <p class="subtitle">使用WebGL着色器技术实现高性能图像处理效果</p>
        </header>
        
        <div class="content">
            <div class="controls">
                <div class="control-group">
                    <h2>滤镜效果</h2>
                    <div class="filter-buttons">
                        <button class="filter-btn active" data-filter="original">原始图像</button>
                        <button class="filter-btn" data-filter="grayscale">灰度</button>
                        <button class="filter-btn" data-filter="invert">反色</button>
                        <button class="filter-btn" data-filter="sepia">怀旧</button>
                        <button class="filter-btn" data-filter="blur">模糊</button>
                        <button class="filter-btn" data-filter="sharpen">锐化</button>
                        <button class="filter-btn" data-filter="edge">边缘检测</button>
                        <button class="filter-btn" data-filter="pixelate">像素化</button>
                        <button class="filter-btn" data-filter="vignette">暗角</button>
                        <button class="filter-btn" data-filter="noise">噪点</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h2>参数调整</h2>
                    <div class="slider-control">
                        <label for="intensity">滤镜强度: <span id="intensity-value">0.5</span></label>
                        <input type="range" id="intensity" min="0" max="1" step="0.01" value="0.5">
                    </div>
                    
                    <div class="slider-control">
                        <label for="brightness">亮度: <span id="brightness-value">0.0</span></label>
                        <input type="range" id="brightness" min="-0.5" max="0.5" step="0.01" value="0.0">
                    </div>
                    
                    <div class="slider-control">
                        <label for="contrast">对比度: <span id="contrast-value">1.0</span></label>
                        <input type="range" id="contrast" min="0.5" max="1.5" step="0.01" value="1.0">
                    </div>
                </div>
                
                <div class="control-group">
                    <h2>图像控制</h2>
                    <button id="reset-btn" class="filter-btn">重置所有参数</button>
                    <button id="upload-btn" class="filter-btn" style="margin-top: 15px;">上传图片</button>
                    <input type="file" id="image-upload" accept="image/*" style="display: none;">
                </div>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-header">
                    <div class="canvas-title">滤镜效果预览</div>
                    <div class="canvas-title" id="filter-name">原始图像</div>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="webgl-canvas" width="800" height="600"></canvas>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h2>WebGL滤镜实现原理</h2>
            <div class="info-content">
                <p>WebGL滤镜通过片元着色器对图像像素进行处理，核心步骤包括：</p>
                
                <div class="tech-list">
                    <div class="tech-item">
                        <h3>纹理加载</h3>
                        <p>将图像作为纹理加载到WebGL中，作为着色器的输入</p>
                    </div>
                    
                    <div class="tech-item">
                        <h3>着色器编程</h3>
                        <p>编写GLSL片元着色器，实现各种滤镜算法</p>
                    </div>
                    
                    <div class="tech-item">
                        <h3>渲染处理</h3>
                        <p>将纹理渲染到画布上，应用着色器效果</p>
                    </div>
                    
                    <div class="tech-item">
                        <h3>参数传递</h3>
                        <p>通过uniform变量将控制参数传递给着色器</p>
                    </div>
                </div>
                
                <h3 style="margin-top: 25px; color: #3498db;">常见滤镜算法</h3>
                <ul style="margin-top: 15px; padding-left: 20px;">
                    <li><strong>灰度滤镜</strong>: 加权平均RGB值 (0.299*R + 0.587*G + 0.114*B)</li>
                    <li><strong>反色滤镜</strong>: 用1.0减去每个颜色通道的值 (1.0 - color)</li>
                    <li><strong>模糊滤镜</strong>: 使用高斯卷积核进行图像卷积</li>
                    <li><strong>边缘检测</strong>: 使用Sobel算子计算梯度</li>
                    <li><strong>像素化</strong>: 将图像分成大块，取块内平均值</li>
                </ul>
            </div>
        </div>
        
        <footer>
            <p>WebGL图像滤镜实现技术 | 高性能实时图像处理 | © 2023</p>
        </footer>
    </div>

    <script>
        // 获取WebGL上下文
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('您的浏览器不支持WebGL，无法运行此演示');
        }
        
        // 创建着色器程序
        function createShaderProgram(vertexSrc, fragmentSrc) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSrc);
            gl.compileShader(vertexShader);
            
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('顶点着色器编译错误:', gl.getShaderInfoLog(vertexShader));
                return null;
            }
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSrc);
            gl.compileShader(fragmentShader);
            
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('片元着色器编译错误:', gl.getShaderInfoLog(fragmentShader));
                return null;
            }
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('着色器程序链接错误:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        // 顶点着色器源码
        const vertexShaderSrc = `
            attribute vec2 aPosition;
            attribute vec2 aTexCoord;
            
            varying vec2 vTexCoord;
            
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
                vTexCoord = aTexCoord;
            }
        `;
        
        // 基础片元着色器源码
        const baseFragmentShaderSrc = `
            precision mediump float;
            
            varying vec2 vTexCoord;
            uniform sampler2D uTexture;
            uniform float uIntensity;
            uniform float uBrightness;
            uniform float uContrast;
            uniform vec2 uResolution;
            
            void main() {
                vec4 color = texture2D(uTexture, vTexCoord);
                gl_FragColor = color;
            }
        `;
        
        // 滤镜着色器集合
        const filterShaders = {
            original: baseFragmentShaderSrc,
            
            grayscale: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                
                void main() {
                    vec4 color = texture2D(uTexture, vTexCoord);
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    vec3 result = mix(color.rgb, vec3(gray), uIntensity);
                    gl_FragColor = vec4(result, color.a);
                }
            `,
            
            invert: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                
                void main() {
                    vec4 color = texture2D(uTexture, vTexCoord);
                    vec3 inverted = vec3(1.0) - color.rgb;
                    vec3 result = mix(color.rgb, inverted, uIntensity);
                    gl_FragColor = vec4(result, color.a);
                }
            `,
            
            sepia: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                
                void main() {
                    vec4 color = texture2D(uTexture, vTexCoord);
                    float r = color.r;
                    float g = color.g;
                    float b = color.b;
                    
                    float tr = 0.393 * r + 0.769 * g + 0.189 * b;
                    float tg = 0.349 * r + 0.686 * g + 0.168 * b;
                    float tb = 0.272 * r + 0.534 * g + 0.131 * b;
                    
                    vec3 sepia = vec3(tr, tg, tb);
                    vec3 result = mix(color.rgb, sepia, uIntensity);
                    gl_FragColor = vec4(result, color.a);
                }
            `,
            
            blur: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                uniform vec2 uResolution;
                
                void main() {
                    vec4 color = vec4(0.0);
                    float blurSize = 1.0 + uIntensity * 20.0;
                    vec2 step = 1.0 / uResolution;
                    
                    // 简单的模糊核
                    color += texture2D(uTexture, vTexCoord + vec2(-step.x, -step.y) * blurSize) * 0.0625;
                    color += texture2D(uTexture, vTexCoord + vec2(0.0, -step.y) * blurSize) * 0.125;
                    color += texture2D(uTexture, vTexCoord + vec2(step.x, -step.y) * blurSize) * 0.0625;
                    
                    color += texture2D(uTexture, vTexCoord + vec2(-step.x, 0.0) * blurSize) * 0.125;
                    color += texture2D(uTexture, vTexCoord) * 0.25;
                    color += texture2D(uTexture, vTexCoord + vec2(step.x, 0.0) * blurSize) * 0.125;
                    
                    color += texture2D(uTexture, vTexCoord + vec2(-step.x, step.y) * blurSize) * 0.0625;
                    color += texture2D(uTexture, vTexCoord + vec2(0.0, step.y) * blurSize) * 0.125;
                    color += texture2D(uTexture, vTexCoord + vec2(step.x, step.y) * blurSize) * 0.0625;
                    
                    gl_FragColor = color;
                }
            `,
            
            sharpen: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                uniform vec2 uResolution;
                
                void main() {
                    vec2 step = 1.0 / uResolution;
                    vec4 color = texture2D(uTexture, vTexCoord) * 5.0;
                    color -= texture2D(uTexture, vTexCoord + vec2(-step.x, -step.y)) * 0.125 * uIntensity;
                    color -= texture2D(uTexture, vTexCoord + vec2(0.0, -step.y)) * 0.25 * uIntensity;
                    color -= texture2D(uTexture, vTexCoord + vec2(step.x, -step.y)) * 0.125 * uIntensity;
                    
                    color -= texture2D(uTexture, vTexCoord + vec2(-step.x, 0.0)) * 0.25 * uIntensity;
                    color -= texture2D(uTexture, vTexCoord + vec2(step.x, 0.0)) * 0.25 * uIntensity;
                    
                    color -= texture2D(uTexture, vTexCoord + vec2(-step.x, step.y)) * 0.125 * uIntensity;
                    color -= texture2D(uTexture, vTexCoord + vec2(0.0, step.y)) * 0.25 * uIntensity;
                    color -= texture2D(uTexture, vTexCoord + vec2(step.x, step.y)) * 0.125 * uIntensity;
                    
                    gl_FragColor = color;
                }
            `,
            
            edge: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                uniform vec2 uResolution;
                
                void main() {
                    vec2 step = 1.0 / uResolution;
                    
                    // Sobel算子
                    vec4 topLeft = texture2D(uTexture, vTexCoord + vec2(-step.x, -step.y));
                    vec4 top = texture2D(uTexture, vTexCoord + vec2(0.0, -step.y));
                    vec4 topRight = texture2D(uTexture, vTexCoord + vec2(step.x, -step.y));
                    
                    vec4 left = texture2D(uTexture, vTexCoord + vec2(-step.x, 0.0));
                    vec4 center = texture2D(uTexture, vTexCoord);
                    vec4 right = texture2D(uTexture, vTexCoord + vec2(step.x, 0.0));
                    
                    vec4 bottomLeft = texture2D(uTexture, vTexCoord + vec2(-step.x, step.y));
                    vec4 bottom = texture2D(uTexture, vTexCoord + vec2(0.0, step.y));
                    vec4 bottomRight = texture2D(uTexture, vTexCoord + vec2(step.x, step.y));
                    
                    // 水平梯度
                    vec4 gx = -topLeft - 2.0 * left - bottomLeft + topRight + 2.0 * right + bottomRight;
                    
                    // 垂直梯度
                    vec4 gy = -topLeft - 2.0 * top - topRight + bottomLeft + 2.0 * bottom + bottomRight;
                    
                    // 梯度幅度
                    vec4 gradient = sqrt(gx * gx + gy * gy);
                    
                    vec3 edgeColor = vec3(1.0 - length(gradient.rgb));
                    vec3 result = mix(texture2D(uTexture, vTexCoord).rgb, edgeColor, uIntensity);
                    gl_FragColor = vec4(result, 1.0);
                }
            `,
            
            pixelate: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                uniform vec2 uResolution;
                
                void main() {
                    float pixelSize = 1.0 + uIntensity * 50.0;
                    vec2 pixelCoord = floor(vTexCoord * uResolution / pixelSize) * pixelSize;
                    vec2 uv = pixelCoord / uResolution;
                    gl_FragColor = texture2D(uTexture, uv);
                }
            `,
            
            vignette: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                
                void main() {
                    vec4 color = texture2D(uTexture, vTexCoord);
                    float dist = distance(vTexCoord, vec2(0.5, 0.5));
                    float vignette = 1.0 - dist * 0.7 * uIntensity;
                    gl_FragColor = color * vignette;
                }
            `,
            
            noise: `
                precision mediump float;
                
                varying vec2 vTexCoord;
                uniform sampler2D uTexture;
                uniform float uIntensity;
                
                float rand(vec2 co) {
                    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                void main() {
                    vec4 color = texture2D(uTexture, vTexCoord);
                    float noise = rand(vTexCoord) * uIntensity * 0.3;
                    gl_FragColor = vec4(color.rgb + vec3(noise), color.a);
                }
            `
        };
        
        // 初始化WebGL
        function initWebGL() {
            // 创建顶点缓冲区
            const vertices = new Float32Array([
                -1, -1,  0, 0,  // 左下
                 1, -1,  1, 0,  // 右下
                -1,  1,  0, 1,  // 左上
                 1,  1,  1, 1   // 右上
            ]);
            
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            // 创建索引缓冲区
            const indices = new Uint16Array([0, 1, 2, 2, 1, 3]);
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            
            // 创建基础着色器程序
            const baseProgram = createShaderProgram(vertexShaderSrc, baseFragmentShaderSrc);
            
            // 创建纹理
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            
            // 加载默认图像
            const image = new Image();
            image.crossOrigin = "Anonymous";
            image.src = "https://images.unsplash.com/photo-1501854140801-50d01698950b?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1200&q=80";
            
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                render(baseProgram);
            };
            
            return {
                baseProgram,
                texture,
                vertexBuffer,
                indexBuffer
            };
        }
        
        // 渲染函数
        function render(program) {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            // 设置顶点属性
            const positionLocation = gl.getAttribLocation(program, "aPosition");
            const texCoordLocation = gl.getAttribLocation(program, "aTexCoord");
            
            gl.bindBuffer(gl.ARRAY_BUFFER, webglData.vertexBuffer);
            
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
            
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);
            
            // 绑定纹理
            const textureLocation = gl.getUniformLocation(program, "uTexture");
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, webglData.texture);
            gl.uniform1i(textureLocation, 0);
            
            // 传递分辨率
            const resolutionLocation = gl.getUniformLocation(program, "uResolution");
            if (resolutionLocation) {
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            }
            
            // 传递参数
            const intensityLocation = gl.getUniformLocation(program, "uIntensity");
            if (intensityLocation) {
                gl.uniform1f(intensityLocation, intensity);
            }
            
            const brightnessLocation = gl.getUniformLocation(program, "uBrightness");
            if (brightnessLocation) {
                gl.uniform1f(brightnessLocation, brightness);
            }
            
            const contrastLocation = gl.getUniformLocation(program, "uContrast");
            if (contrastLocation) {
                gl.uniform1f(contrastLocation, contrast);
            }
            
            // 绘制
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webglData.indexBuffer);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        
        // 全局变量
        let currentFilter = 'original';
        let intensity = 0.5;
        let brightness = 0.0;
        let contrast = 1.0;
        let webglData;
        
        // 初始化
        window.onload = function() {
            webglData = initWebGL();
            setupEventListeners();
        };
        
        // 设置事件监听
        function setupEventListeners() {
            // 滤镜按钮
            const filterButtons = document.querySelectorAll('.filter-btn[data-filter]');
            filterButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // 更新按钮状态
                    filterButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 更新当前滤镜
                    currentFilter = this.dataset.filter;
                    document.getElementById('filter-name').textContent = this.textContent;
                    
                    // 创建并应用新着色器
                    const vertexSrc = vertexShaderSrc;
                    const fragmentSrc = filterShaders[currentFilter];
                    const program = createShaderProgram(vertexSrc, fragmentSrc);
                    
                    render(program);
                });
            });
            
            // 强度滑块
            const intensitySlider = document.getElementById('intensity');
            const intensityValue = document.getElementById('intensity-value');
            
            intensitySlider.addEventListener('input', function() {
                intensity = parseFloat(this.value);
                intensityValue.textContent = intensity.toFixed(2);
                
                const vertexSrc = vertexShaderSrc;
                const fragmentSrc = filterShaders[currentFilter];
                const program = createShaderProgram(vertexSrc, fragmentSrc);
                
                render(program);
            });
            
            // 亮度滑块
            const brightnessSlider = document.getElementById('brightness');
            const brightnessValue = document.getElementById('brightness-value');
            
            brightnessSlider.addEventListener('input', function() {
                brightness = parseFloat(this.value);
                brightnessValue.textContent = brightness.toFixed(2);
                
                const vertexSrc = vertexShaderSrc;
                const fragmentSrc = filterShaders[currentFilter];
                const program = createShaderProgram(vertexSrc, fragmentSrc);
                
                render(program);
            });
            
            // 对比度滑块
            const contrastSlider = document.getElementById('contrast');
            const contrastValue = document.getElementById('contrast-value');
            
            contrastSlider.addEventListener('input', function() {
                contrast = parseFloat(this.value);
                contrastValue.textContent = contrast.toFixed(2);
                
                const vertexSrc = vertexShaderSrc;
                const fragmentSrc = filterShaders[currentFilter];
                const program = createShaderProgram(vertexSrc, fragmentSrc);
                
                render(program);
            });
            
            // 重置按钮
            document.getElementById('reset-btn').addEventListener('click', function() {
                // 重置参数
                intensity = 0.5;
                brightness = 0.0;
                contrast = 1.0;
                
                // 更新UI
                intensitySlider.value = intensity;
                intensityValue.textContent = intensity.toFixed(2);
                
                brightnessSlider.value = brightness;
                brightnessValue.textContent = brightness.toFixed(2);
                
                contrastSlider.value = contrast;
                contrastValue.textContent = contrast.toFixed(2);
                
                // 重新渲染
                const vertexSrc = vertexShaderSrc;
                const fragmentSrc = filterShaders[currentFilter];
                const program = createShaderProgram(vertexSrc, fragmentSrc);
                
                render(program);
            });
            
            // 图片上传
            document.getElementById('upload-btn').addEventListener('click', function() {
                document.getElementById('image-upload').click();
            });
            
            document.getElementById('image-upload').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const image = new Image();
                    image.onload = function() {
                        gl.bindTexture(gl.TEXTURE_2D, webglData.texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                        
                        const vertexSrc = vertexShaderSrc;
                        const fragmentSrc = filterShaders[currentFilter];
                        const program = createShaderProgram(vertexSrc, fragmentSrc);
                        
                        render(program);
                    };
                    image.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
    </script>
</body>
</html>